"""
案例: 闭包入门.

闭包解释:
    概述:
        内部函数 使用了外部函数的变量, 这种写法就称之为闭包.
    格式:
        def 外部函数名(形参列表):
            外部函数的(局部)变量

            def 内部函数名(形参列表):
                使用外部函数的变量

            return 内部函数名
    前提条件:
        1. 有嵌套.         外部函数嵌套内部函数
        2. 有引用.         内部函数使用外部函数的变量
        3. 有返回.         外部函数中, 返回 内部函数名(对象)

细节:
    1. 函数名 和 函数名() 是两个概念, 前者表示 函数对象, 后者表示 调用函数, 获取返回值.
"""
def get_sum(a,b):
    return a+b

print(get_sum)  # <function get_sum at 0x000001B4AC3DD800>, 对象.
print(get_sum(10, 20))      # 调用函数, 获取返回值.

# 函数名可以赋值给变量, 这个变量就是: 函数对象.
my_sum = get_sum
print(my_sum)   # <function get_sum at 0x00000251CE53D800>
print(my_sum(100, 200))     # 300
print('-' * 23)


# 案例2: 演示闭包写法.
# 需求: 定义求和的闭包, 外部函数有参数num1, 内部函数有参数num2, 调用, 求解两数之和, 观察结果.
# 就是返回函数对象呗，然后内部函数捕获了外部函数变量，
# 最后当外部函数终止的时候，内部函数依旧可以使用外部函数变量

"""
步骤 1：定义函数 → 加载到【代码对象区（方法区）】
当 Python 运行到def fn_outer(...)时：
不会执行函数体，而是把fn_outer的代码逻辑（包括内部的fn_inner定义）编译成 “代码对象”，存入代码对象区（方法区）；
同时在内存中创建fn_outer这个 “函数对象”（指向代码对象），存入堆内存；
此时栈为空，因为只是定义，没有调用。
步骤 2：执行fn_inner = fn_outer(10) → 栈 + 堆的核心操作
这一步是闭包的关键，分 2 个子步骤：
子步骤 2.1：调用fn_outer(10) → 栈中创建执行上下文
Python 在调用栈中为fn_outer创建一个 “栈帧”（执行上下文）；
把参数num1=10存入这个栈帧（临时变量，理论上函数执行完栈帧就该释放）；
执行fn_outer内部代码：运行到def fn_inner(...)时，同样把fn_inner的代码对象存入代码对象区，并在堆中创建fn_inner函数对象；
✨ 关键：fn_inner函数对象会引用栈帧中的 num1=10，并把这个引用保存到堆内存（闭包的核心：堆里的 fn_inner “抓着” 栈里的 num1 不放）；
执行return fn_inner：把堆中的fn_inner函数对象返回。
子步骤 2.2：栈帧释放，但堆中的闭包保留 num1
fn_outer执行完毕，它的栈帧本应被销毁（栈的特性：先进后出，用完就清）；
但因为堆中的fn_inner函数对象还引用着num1=10，Python 会把num1=10从栈转移到堆内存（绑定到fn_inner的闭包环境中）；
最终：变量fn_inner（全局变量，存在堆）指向堆中的fn_inner函数对象（带闭包环境num1=10）。
步骤 3：执行fn_inner(20) → 栈中执行闭包逻辑
Python 在调用栈中为fn_inner创建新的栈帧；
把参数num2=20存入这个栈帧；
执行fn_inner内部代码：
从堆中的闭包环境取出num1=10，和栈帧中的num2=20相加，得到total=30（total也存在栈帧中）；
执行print，输出 “求和结果: 30”；
fn_inner执行完毕，它的栈帧被销毁（num2、total释放），但堆中的fn_inner函数对象（带num1=10）依然存在（可以继续调用fn_inner(30)）。
"""

def fn_outer(num1):
    def fn_inner(num2): # 有嵌套# 【步骤3】仅定义内部函数，不执行其内部代码
        total = num1 + num2   # 有引用 # 【未执行】只有调用fn_inner时才会执行
        print(f'求和结果: {total}')
    return fn_inner# 有返回# 【步骤4】返回内部函数本身，结束fn_outer执行

fn_inner = fn_outer(10)
fn_inner(20)# 30
fn_inner(30)# 40
fn_inner(40)# 50

print('-' * 23)
#简单写法
fn_outer(10)(20)# 30
"""
fn_outer(10)(20) 
↓ 等价于 ↓
[fn_outer(10)] (20)  # 把第一步的结果当成函数，再传20调用
↓ 等价于 ↓
fn_inner(20)         # 因为fn_outer(10)返回的就是fn_inner（绑定了num1=10）
"""
