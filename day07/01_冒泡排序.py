"""
案例: 演示冒泡排序.

冒泡排序介绍:
    原理:
        相邻元素两两比较, 大的往后走, 这样第一轮比较完毕后, 最大值就在最大索引处.
        重复此动作, 直至排序完成.
    流程: 假设共 5 个元素
           第几轮(索引)         该轮比较的总次数         公式
            第1轮(0):            4次               5 - 1 - 0 = 4
            第2轮(1):            3次               5 - 1 - 1 = 3
            第3轮(2):            2次               5 - 1 - 2 = 2
            第4轮(3):            1次               5 - 1 - 3 = 1
    要点:
       1. 比较的总轮数.        列表长度 - 1
       2. 每轮比较的总次数.     列表长度 - 1 - 轮数的索引(从0开始)
       3. 谁和谁比较.          索引j 和 j + 1位置的元素比较
    时间复杂度:
        最优: O(n)
        最坏: O(n²)
    扩展:
        冒泡排序 = 稳定 排序算法
    扩展:
        外循环的 -1 是什么意思: 减少比较的轮数, 提高效率.
        内循环的 -1 是什么意思: 为了防止索引 越界.
        内循环的 -i 是什么意思: 减少每轮比较的次数, 提高效率.
"""

# 1. 定义函数 bubble_sort(my_list), 表示: 冒泡排序.
def bubble_sort(my_list):
    length = len(my_list)
    for i in range(length - 1):
        for j in range(length - 1 - i):
            if my_list[j] > my_list[j + 1]:
                my_list[j], my_list[j + 1] = my_list[j + 1], my_list[j]
    return my_list

if __name__ == '__main__':
    print(bubble_sort([1, 2, 3, 4, 5]))