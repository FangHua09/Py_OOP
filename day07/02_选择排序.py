"""
案例: 演示选择排序.

选择排序介绍:
    原理:
        每轮都假设该轮最前边的那个元素为最小值, 然后去 剩下的元素列表中找真正的最小值, 最终交换即可, 本轮就找到了 本轮的最小值, 重复即可.
    大白话:
        第1轮, 假设 i = 0位置的元素是最小值, 然后用min_index记录住它的索引, 然后去剩下所有元素中找真正的最小值, 找到后就用min_index做记录, 最终判断i 和 min_index是否交换,
        第1轮完毕后, 最小值就在最小索引处.
        重复该步骤, 直至排序完成.
    流程: 假设共 5 个元素
           第几轮(索引)         该轮比较的总次数         公式(具体的谁和谁比较)
            第1轮(0):            4次                    索引0和 1,2,3,4比较
            第2轮(1):            3次                    索引1和 2,3,4比较
            第3轮(2):            2次                    索引2和 3,4比较
            第4轮(3):            1次                    索引3和 4比较
    要点:
       1. 比较的总轮数.        列表长度 - 1
       2. 每轮比较的总次数.     i+1 ~ n
       3. 谁和谁比较.          索引min_index(初值为i) 和 索引j比较,  索引i 和 索引min_index的值交换
    时间复杂度:
        最优: O(n²)
        最坏: O(n²)
    扩展:
        选择排序 = 不稳定 排序算法
    扩展:
        外循环的 -1 是什么意思: 减少比较的轮数, 提高效率.
"""

# 1. 定义函数select_sort(my_list), 表示: 选择排序.
def select_sort(my_list):
    n = len(my_list)
    #外循环控制比较轮数
    for i in range(n-1):
        min_idx = i#暂时记录最左侧为最小元素
        for j in range(i+1,n):#找到本轮真正最小元素
            if my_list[j]<my_list[min_idx]:
                min_idx = j
        if min_idx != i:
            my_list[min_idx],my_list[i] = my_list[i],my_list[min_idx]
    return my_list

if __name__ == '__main__':
    print(select_sort([2, 7, 9, 6, 7]))
